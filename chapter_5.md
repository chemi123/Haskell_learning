# すごいHな勉強会
## 第五章 - 高階関数
Haskellの関数は、引数として関数をとったり返り値として関数を返したりできる。そのような関数を**高階関数**と呼ぶ。

### カリー化関数
Haskellの全ての関数は公式には引数を一つだけとることになっている。
では引数を二つ以上とる関数は？  
-> **カリー化**されている  

#### カリー化とは？
wikipediaより
```
複数の引数をとる関数を、引数が「もとの関数の最初の引数」で戻り値が「もとの関数の残りの引数を取り結果を返す関数」であるような関数にすること
```
言葉だとアレなので例を使って説明。  
例えばmax関数で`max 4 5`という式について考えてみる。  
一見すると引数を二つとる関数に見えるが、実際の内部の処理は以下フローになっている。  
1. `max 4`を適用する
2. 返り値として5を適用するための別の関数fを返す
3. その関数fに5が適用されて最終的な数値が返る

以上のことが起きるため、以下二つの式は等価である。
```
Prelude> max 4 5
5
Prelude> (max 4) 5
5
```
型宣言を使って考えて見る。  
max関数の型宣言は`a -> a -> a`となっている(型クラス制約は省略) 。よく見るとこれは`a -> (a -> a)`とみなすことができる。  
`A = (a -> a)`とするとmaxの型宣言は`a -> A`と表現できる。`A`とは引数を一つとって値を返す関数であるとみなすことができる。  
そのため`a -> (a -> a)`とは「引数を一つ取り、引数を一つとって値をとる関数を返す関数である」と考えることができる。

このようなカリー化の特性によって**部分適用**をすることができる。  
以下部分適用の例
```
Prelude> f = max 4
Prelude> :t f
f :: (Ord a, Num a) => a -> a
Prelude> f 8
8
```

maxはは本来引数を二つとる関数であるが、引数を一つだけ与えた関数を作っている例。  
この関数使ってまた別の関数を作り出すと行ったことができる。  


もちろん引数が三つ以上の関数に関しても同じようにカリー化はされている。  
3つの引数を掛け合わせるだけの簡単な関数を例に考えてみる。
```
multThree :: Int -> Int -> Int -> Int
multThree x y z = x * y * z
```
このmultThreeの型宣言は`Int -> (Int -> (Int -> Int))`とみなすことができる。  
この関数に対して徐々に引数を与えると型宣言が以下のようにしていく。
```
// Int -> (Int -> (Int -> Int))とみなすことができる
// Int型の引数を一つとり関数を一つ返すというイメージ
*Main> :t multTree
multTree :: Int -> Int -> Int -> Int

// Int -> (Int -> Int)とみなせる
// Int型の引数を一つとり、Int型の引数を一つとってInt型の値を返す関数を返す
*Main> :t multTree 2
multTree 2 :: Int -> Int -> Int

// Int型の引数を一つとってInt型の値を返す関数
*Main> :t multTree 2 3
multTree 2 3 :: Int -> Int

// Int型の値
*Main> :t multTree 2 3 4
multTree 2 3 4 :: Int
```
このようにカリー化されていることで部分適用を行ったり、関数を丸ごと他の関数の引数にすることができる。  

#### 関数を表示する
一部引数を与えた状態で表示しようとしたらどうなるのだろうか？
```
*Main> multTree 2 3

<interactive>:7:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
```
当たり前(?)だがエラーメッセージが出力される。  
内容は`Int -> Int`の型の関数を作ったけど表示しようがないという内容。  
この関数はShow型クラスのインスタンスではないのでいい感じに画面に関数を表示する方法がわからないと怒られている。  
画面に出力される型は必ずShow型クラスのインスタンスである必要がある。  
普段何気なくInt型の値を画面に出力しているがこれはInt型がShow型クラスのインスタンスであるから出力できている。

### 高階実演
Haskellの関数は関数を引数にも返り値にもすることができることを説明した。  
ここで関数を引数にとる関数applyTwiceについて考えてみる。  
```
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)
```
関数を引数にとる場合は引数にとる関数に対応する型を括弧で囲うことで明示的に関数を引数にとると指定しなければならない。  
この関数の型宣言は`(a -> a) -> (a -> a)`とみなすことができる。  
つまり引数を一つとる関数を引数としてとることで、引数を一つとる関数を返す関数となる。

#### zipWith
高階プログラミングを使うことでzipWithを実装してみる。  
pythonにも似た関数でzipがある。  
リストの表現方法とパターンマッチと再帰と高階関数の応用としての好例。
```
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' f [] _ = []
zipWith' f _ [] = []
zipWith' f (x:xs) (y:ys) = (f x y) : zipWith' f xs ys
```

### 関数プログラマの道具箱
Haskellでよく使う(?)関数を紹介
#### map関数
map関数は関数とリストを受け取り、その関数をリストの全ての要素に適用して新しいリストを生成する。  
```
map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map' f xs
```

#### filter関数
filter関数はBoolを返す関数(述語と言うらしい)とリストを受け取ってリストの要素に適用し、Falseならその要素をはじく。
```
filter :: (a -> Bool) -> [a] -> [a]
filter f [] = []
filter f (x:xs)
  | f x = x : filter' f xs
  | otherwise = filter' f xs
```

### ラムダ式
ラムダ式とは一回だけ必要な関数を作る時に使う無名関数。  
`\`を使ってラムダ式を宣言する。通常は高階関数の引数に渡す時に用いられる。  
以下はラムダ式の例
```
*Main> map (\x -> x^(x `div` 2)) [1..10]
[1,2,3,16,25,216,343,4096,6561,100000]
```

ラムダ式は無駄に使う必要はない。
```
// 以下二つは等価であるが(+3)の方が可読性が高い
*Main> map (+3) [1..10]
[4,5,6,7,8,9,10,11,12,13]
*Main> map (\x -> x+3) [1..10]
[4,5,6,7,8,9,10,11,12,13]
```

ラムダ式によるパターンマッチもできる。
```
*Main> map (\(a, b) -> a + b) [(1, 2), (3, 4), (5, 6)]
[3,7,11]
```

### 畳み込み
