# すごいHな勉強会
## 第五章 - 高階関数
Haskellの関数は、引数として関数をとったり返り値として関数を返したりできる。そのような関数を**高階関数**と呼ぶ。

### カリー化関数
Haskellの全ての関数は公式には引数を一つだけとることになっている。
では引数を二つ以上とる関数は？  
-> **カリー化**されている  

#### カリー化とは？
wikipediaより
```
複数の引数をとる関数を、引数が「もとの関数の最初の引数」で戻り値が「もとの関数の残りの引数を取り結果を返す関数」であるような関数にすること
```
言葉だとアレなので例を使って説明。  
例えばmax関数で`max 4 5`という式について考えてみる。  
一見すると引数を二つとる関数に見えるが、実際の内部の処理は以下フローになっている。  
1. 4に`max`を適用する
2. 返り値として5を適用するための別の関数fを返す
3. そして5にその関数fが適用されて最終的な数値が返る

以上のことが起きるため、以下二つの式は等価である。
```
Prelude> max 4 5
5
Prelude> (max 4) 5
5
```
型宣言を使って考えて見る。  
max関数の型宣言は`a -> a -> a`となっている(型クラス制約は省略) 。よく見るとこれは`a -> (a -> a)`とみなすことができる。  
`A = (a -> a)`とするとmaxの型宣言は`a -> A`と表現できる。`A`とは引数を一つとって値を返す関数であるとみなすことができる。  
そのため`a -> (a -> a)`とは「引数を一つ取り、引数を一つとって値をとる関数を返す関数である」と考えることができる。

このようなカリー化の特性によって**部分適用**をすることができる。  
カリー化の特性からHaskellは関数も値も区別していない事がわかる。  
以下部分適用の例
```
Prelude> f = max 4
Prelude> :t f
f :: (Ord a, Num a) => a -> a
Prelude> f 8
8
```

maxはは本来引数を二つとる関数であるが、引数を一つだけ与えた関数を作っている例。  
この関数使ってまた別の関数を作り出すといったことができる。  


もちろん引数が三つ以上の関数に関しても同じようにカリー化はされている。  
3つの引数を掛け合わせるだけの簡単な関数を例に考えてみる。
```
multThree :: Int -> Int -> Int -> Int
multThree x y z = x * y * z
```
このmultThreeの型宣言は`Int -> (Int -> (Int -> Int))`とみなすことができる。  
この関数に対して徐々に引数を与えると型宣言が以下のようにしていく。
```
// Int -> (Int -> (Int -> Int))とみなすことができる
// Int型の引数を一つとり関数を一つ返すというイメージ
*Main> :t multTree
multTree :: Int -> Int -> Int -> Int

// Int -> (Int -> Int)とみなせる
// Int型の引数を一つとり、Int型の引数を一つとってInt型の値を返す関数を返す
*Main> :t multTree 2
multTree 2 :: Int -> Int -> Int

// Int型の引数を一つとってInt型の値を返す関数
*Main> :t multTree 2 3
multTree 2 3 :: Int -> Int

// Int型の値
*Main> :t multTree 2 3 4
multTree 2 3 4 :: Int
```
このようにカリー化されていることで部分適用を行ったり、関数を丸ごと他の関数の引数にすることができる。  

#### 関数を表示する
一部引数を与えた状態で表示しようとしたらどうなるのだろうか？
```
*Main> multTree 2 3

<interactive>:7:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
```
当たり前(?)だがエラーメッセージが出力される。  
`Int -> Int`の型の関数を作ったけど表示しようがないという内容。  
この関数はShow型クラスのインスタンスではないのでいい感じに画面に関数を表示する方法がわからないと怒られている。  
画面に出力される型は必ずShow型クラスのインスタンスである必要がある。  
普段何気なくInt型の値を画面に出力しているがこれはInt型がShow型クラスのインスタンスであるから出力できている。

### 高階実演
Haskellの関数は関数を引数にも返り値にもすることができることを説明した。  
ここで関数を引数にとる関数applyTwiceについて考えてみる。  
```
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)
```
関数を引数にとる場合は引数にとる関数に対応する型を括弧で囲うことで明示的に関数を引数にとると指定しなければならない。  
この関数の型宣言は`(a -> a) -> (a -> a)`とみなすことができる。  
つまり引数を一つとる関数を引数としてとることで、引数を一つとる関数を返す関数となる。

#### zipWith
高階プログラミングを使うことでzipWithを実装してみる。  
pythonにも似た関数でzipがある。  
リストの表現方法とパターンマッチと再帰と高階関数の応用としての好例。
```
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' f [] _ = []
zipWith' f _ [] = []
zipWith' f (x:xs) (y:ys) = (f x y) : zipWith' f xs ys
```

### 関数プログラマの道具箱
Haskellでよく使う(?)関数を紹介
#### map関数
map関数は関数とリストを受け取り、その関数をリストの全ての要素に適用して新しいリストを生成する。  
```
map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map' f xs
```

#### filter関数
filter関数はBoolを返す関数(述語と言うらしい)とリストを受け取ってリストの要素に適用し、Falseならその要素をはじく。
```
filter :: (a -> Bool) -> [a] -> [a]
filter f [] = []
filter f (x:xs)
  | f x = x : filter' f xs
  | otherwise = filter' f xs
```

### ラムダ式
ラムダ式とは一回だけ必要な関数を作る時に使う無名関数。  
`\`を使ってラムダ式を宣言する。通常は高階関数の引数に渡す時に用いられる。  
以下はラムダ式の例
```
*Main> map (\x -> x^(x `div` 2)) [1..10]
[1,2,3,16,25,216,343,4096,6561,100000]
```

ラムダ式は無駄に使う必要はない。
```
// 以下二つは等価であるが(+3)の方が可読性が高い
*Main> map (+3) [1..10]
[4,5,6,7,8,9,10,11,12,13]
*Main> map (\x -> x+3) [1..10]
[4,5,6,7,8,9,10,11,12,13]
```

ラムダ式によるパターンマッチもできる。
```
*Main> map (\(a, b) -> a + b) [(1, 2), (3, 4), (5, 6)]
[3,7,11]
```

### 畳み込み
Haskellでリストに対する再帰関数を定義するにおいて多くのパターンは「基底部は空リストとし、x:xsパターンを使ってリストを先頭要素と残りのリストを分解する」である。  
この頻出するパターンに対応するため**畳み込み**(fold)と呼ばれる便利な関数がいくつか用意されている。

畳み込みは2引数関数と初期値と畳み込むリストを受け取る。  
リストは右からでも左からでも畳み込むことができる。アキュームレータが計算過程の値となり、リストの最後の要素が終わった時点でのアキュームレータの値が結果となる。

#### foldl
リストを左から順に畳み込んでいくので**左畳み込み**関数と呼ばれる。2引数関数とアキュームレータの初期値とリストを引数にとる。  
最初のアキュームレータとリストの先頭要素に2引数関数を適当してアキュームレータを更新する作業をリストが空になるまで繰り返す。  

```
foldl' :: (a -> b -> a) -> b -> [a] -> a
foldl' f acc [] = acc
foldl' f acc (x:xs) = foldl' f (f x acc) xs
```

#### foldr
foldlとは逆にリストを右から順に畳み込むので**右畳み込み**関数と呼ばれる。  

```
foldr' :: (a -> b -> b) -> b -> [a] -> b
foldr' f acc [] = acc
foldr' f acc (x:xs) = f x (foldr' f acc xs)
```

使用例(何も面白くない)
```
// 1から10までのリストを全て足し合わせる場合(初期値は0)
*Main> foldl (+) 0 [1..10]
55
*Main> foldr (+) 0 [1..10]
55
```

#### foldlとfoldrの違い
まずはfoldlとfoldrの挙動を説明する。  
sum関数をfoldlとfoldrで実装してみると以下のようになる。
```
suml :: (Num a) => [a] -> a
suml = foldl (+) 0

sumr :: (Num a) => [a] -> a
sumr = foldr (+) 0
```
これらを使って`[1,2,3,4]`を引数にとった場合以下のようになる(厳密ではないが分かりやすさを重視)。  
```
// suml
((((0+1)+2)+3)+4)

// sumr
(1+(2+(3+(4+0))))
```
このためfoldに渡す二引数関数が`(+)`だと同じ結果になるが`(-)`だとfoldrの場合マイナスがマイナスを打ち消したりしてよくわからない結果になるためあまり`(-)`を使って演算するのはおすすめしない。  

計算時のメモリ使用量という観点からfoldlの方が効率良く処理できるため基本的にはfoldlを推奨。  
しかし以下のケースに当てはまる場合はfoldrの方が推奨される。  
- リストから新しいリストを出力する場合
- リストが無限リストである場合

##### リストから新しいリストを出力する場合
mapをfoldl, foldrで実装する事によって確認してみる
```
// foldlで実装
mapl :: (a -> b) -> [a] -> [b]
mapl f xs = foldl (\acc x -> acc ++ [f x]) [] xs

// foldrで実装
mapr :: (a -> b) -> [a] -> [b]
mapr f xs = foldr (\x acc -> f x : acc) [] xs
```
計算過程においてacc(アキュームレータの)の来る位置によってリストを作るやり方が変わってくる。  
foldlだとaccはどうしても左側にきてしまうので`:`を使うとリストが反転してしまうため、`++`でリストの結合を行う。  
それに対してfoldrだとaccが右側に来るため`:`を使う事でリストを作ることができる。  
`++`によるリストの結合は時間がかかるためリストからリストを作るときはfoldrを使う方が望ましい(同様にaccの位置による理由からreverse関数を実装する場合はfoldlがベター)。  

##### リストが無限リストである場合  
Haskellの遅延評価であるという特性からfoldrだと上手く動作する(というかfoldlだと動作しない)。  
その理由は以下の公式からの特性による。  
[foldl](http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:foldl)  
[foldr](http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:foldr)
```
// foldl
(...((z `f` x1) `f` x2) `f`...) `f` xn

// foldr
x1 `f` (x2 `f` ... (xn `f` z)...)
```
まずfoldlについて見てみる。  
遅延評価は大雑把に言うと外側から評価していくらしい(詳しくは良くわかってないが現在はそんなものだという認識)。  
そこでfoldlの外側は``...)　`f` xn``となっているが無限リストのためxnはいつまでも広がり続けいつまでも最後のxnを評価する事ができない。

それに対してfoldrの場合一番外側は``x1 `f` (x2 ...``となっているためx1を始めに評価することができる。  
以上がfoldrが無限リストを扱う事ができる理由である。  

#### 畳み込みについての補足
計算過程の結果を知りたい人はscanl, scanrを使ってね！  
あと初期値がデフォルトで0でもいいならfoldl1, foldr1もあるよ！

### $を使った関数適用
`$`関数、またの名を**関数適用演算子**について見てみる。  
```
($) :: (a -> b) -> a -> b
f $ x = f x
```
一見するとただ関数を適用しているだけの無意味な関数に見える。  
実はこれは関数適用の際の優先順位が一番低くなる関数である(関数の適用自体は一番高い優先順位である)。  
この`$`を使う事によって括弧を減らす事ができる。  
以下例
```
// 3にsqrtが適用され、その結果に4と5がプラスされる
*Main> sqrt 3 + 4 + 5
10.732050807568877

// 3+4+5にsqrtが適用される
*Main> sqrt (3 + 4 + 5)
3.4641016151377544

// $を使って同じように表現する
*Main> sqrt $ 3 + 4 + 5
3.4641016151377544
```

### 関数合成
数学における`(f○g)(x)=f(g(x))`のように定義される関数合成はHaskellでも実現できる。  
`.`演算子を使う。以下は定義。  
```
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
```
他の関数に渡す関数をその場で作るとき等に使う。ラムダ式でも良いが関数合成の方が簡潔になる事が多い。  
以下はリスト中の数を全て負の値にしたいときの例。  
```
// ラムダ式を使った場合
Prelude> map (\x -> negate (abs x)) [5, -4, -6, 8, 4, -1, -10, 49]
[-5,-4,-6,-8,-4,-1,-10,-49]

// 関数合成を使った場合
Prelude> map (negate . abs) [5, -4, -6, 8, 4, -1, -10, 49]
[-5,-4,-6,-8,-4,-1,-10,-49]
```

#### 多引数関数の合成関数
複数の引数を取る関数でも部分適用すれば関数合成はできる。  
```
// 純粋に括弧のみを使った場合
Prelude> sum (replicate 5 (max 4 9))
45

// 関数合成をしてみる(replicate 5が部分適用)
Prelude> (sum . replicate 5) (max 4 9)
45

// もう少しすっきり
Prelude> sum . replicate 5 $ max 4 9
45
```
最初は慣れないと思う(実際自分もやってて良くわからなくなってくる)ので手を動かしていろいろ試してみると良いと思う。  

#### ポイントフリースタイル
関数合成のもう一つの一般的な使い道は**ポイントフリースタイル**で関数を定義するというものである。  
ポイントとは関数を定義する際に使う一時変数(例えばx)のことである。  
これを使わない事をポイントフリースタイルと呼ぶ。  
```
// 例としてfoldl関数を使ってまずはポイントフリースタイルでない関数sumlを定義
Prelude> suml xs = foldl1 (+) xs

// カリー化の特性から変数xsは省略できる
Prelude> suml = foldl1 (+)
```

以下は関数合成を使ってポイントフリースタイルで記述する例
```
// xを消したい
Prelude> fn x = ceiling (negate (tan (cos (max 50 x))))

// ポイントフリースタイル及び関数合成で記述する事で見た目もすっきりしてxを消す事ができた
fn = ceiling . negate . tan . cos . max 50
```

### 参考URL
http://succzero.hatenablog.com/entry/2013/12/07/234808
