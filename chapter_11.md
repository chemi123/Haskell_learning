# すごいHな勉強会
## 第十一章 - ファンクターからアプリカティブファンクターへ
### 帰ってきたファンクター
まずはファンクターの復習を少しだけ。  
ファンクターとは関数で写せるもののことで、例えばリストやMaybe、木などがファンクターである(厳密には木は自分で定義する必要があるがファンクターになり得る)。  
ファンクターは型クラスのFunctorで表現され、Functorの提供するメソッドはfmapの一つだけである。  
そしてfmapの型宣言は`fmap :: (Functor f) => (a -> b) -> f a -> f b`となっており、この意味は(ざっくり言えば)`「aをとってbを返す関数」と「fという箱に入ったa」を渡すことで「fにbが入った箱」が返る`ということになる。

型コンストラクタをFunctorのインスタンスにするためには、その型コンストラクタの種類(kind)が`* -> *`である必要がある。つまりその型コンストラクタは具体型の型引数を何か一つ取ることで具体型になるものである必要がある。  
例えばMaybeはMaybe IntやMaybe Stringのように1つ型変数を取って具体型を生むのでファンクターになれる。  
それに対してEitherのように二つ型引数を取る型コンストラクタでをファンクターにするには型引数を一つ与えることで部分適用をして後一つだけ型引数を取れる状態にすれば良い。  
そのためMaybe及びEitherをFunctorのインスタンスにするにはそれぞれ
```
instance Functor Maybe where
instance Functor (Either a) where
```
とすれば正しくインスタンス宣言ができる。この場合fmapの型宣言はそれぞれ
```
fmap :: (a -> b) -> Maybe a -> Maybe b
fmap :: (b -> c) -> Either a b -> Either a c
```
となる。

#### ファンクターとしてのI/Oアクション
今までファンクターのインスタンスになれる型コンストラクタとして主にMaybeやリスト、Either a等を見てきた。実はIOもファンクター型クラスのインスタンスであるのでここで少し見ていく。以下はIOのFunctorインスタンス定義である。

```
instance Functor IO where
  fmap f action = do
    result <- action
    return (f result)
```

このfmapの型宣言は`(a -> b) -> IO a -> IO b`であることを踏まえるとactionはIO a型となるためまずI/Oアクションを実行して得られた結果をresultに束縛する。  
そしてresultに関数fを適用して得られた結果をreturnで返す。returnは`(Monad m) => a -> m a`であるため、文脈に沿ってmをIOとして返してくれる。  

IOのfmapの例として以下のように標準入力から得られた結果を文字列として束縛した変数にreverseを適用する場合を見てみる。

```
// fmapを使わない場合
main = do
  line <- getLine
  let line' = reverse line
  putStrLn line'

// fmapを使う場合
main = do
  line <- fmap reverse getLine
  putStrLn line
```

IO aのfmapはI/Oアクションをして得られた結果に対して関数を適用し、その結果を返すという役割を果たす。

#### ファンクターとしての関数
Functorのインスタンスをよくみると一見よくわからない型がある。

```
*Main> :i Functor
class Functor (f :: * -> *) where
  fmap :: (a -> b) -> f a -> f b
  (<$) :: a -> f b -> f a
  {-# MINIMAL fmap #-}
        -- Defined in ‘GHC.Base
...        
instance Functor ((->) r) -- Defined in ‘GHC.Base’
...
```

一見何のことかよくわからないというのはこの`((->) r)`のことである。実はこれは関数を表している。もっと言えば`(->)`は型引数を二つ取ることで関数という具体型になれる型コンストラクタを示している。
`(+) 1 1`などと表現しているものに近い。そして関数がFunctorのインスタンスであるということは関数でさえもfmapで写すことができるということである。  
一般的なfmapの型宣言が`(Functor f) => (a -> b) -> f a -> f b`であることを考えると、関数のfmapの型宣言は以下のように表現できる。

```
fmap :: (a -> b) -> ((->) r a) -> ((->) r b)
```
更に、`(->)`は単純に引数に適用されているため中置記法で示すと以下のようになる。
```
fmap :: (a -> b) -> (r -> a) -> (r -> b)
```
これは引数を一つ取る関数を二つ受け取って引数を一つ取る関数を返し、そして返ってくる関数は一引数目の関数が返す型と同じである。
この型宣言を考えて((->) r)をFunctorインスタンス定義をすると以下のようになる。

```
instance Functor ((->) r) where
  fmap f g = \x -> f (g x)
```
これはよくみると関数合成のことになる。xをgに適用した結果をfで写すという意味として捉えることができる。  
`(.)`は関数合成を表しているため`fmap = (.)`と表現することもできる。
以下fmapで簡単な関数を合成してみる。

```
*Main> f = fmap (*3) (+100)
*Main> f 1
303

// 中置記法でもOK
*Main> f = (*3) `fmap` (+100)
*Main> f 1
303
```

ここでもう一度fmapの一般的な型宣言を見てみる。
```
fmap :: (Functor f) => (a -> b) -> f a -> f b
```

Haskellのカリー化という特性を思い出してみると、基本的に関数は引数を一つしか取らないというものである。  
つまりa -> b -> cという型宣言の関数があった場合はa -> (b -> c)と表現することができ、これはaという型の引数を一つとりb -> cという関数を返すものであるという意味になる。これを踏まえるとfmapは以下のように捉えることができる。
```
fmap :: (Functor f) => (a -> b) -> (f a -> f b)
```

このように見てみるとfmapは「aを取ってbを返す」関数を引数として取り、「f aを取ってf bを返す」関数を返すように見える。もっと言えば「ファンクター値をとってファンクター値を返す」関数と捉えることができる。fmapはa -> bを取ってf a -> f bを返す。  
このような操作を関数の**持ち上げ**(**lifting**)という。  
例えば一引数関数にfmapを適用した例を以下に示してみる。

このliftingの概念とMaybe a型等のFunctor値を関数で写す概念から、fmapは以下二通りの考え方ができる。

1. fmapは関数とファンクター値を取って、その関数でファンクター値を写して返す関数
2. fmapは値から値への関数を取って、それをファンクター値からファンクター値への関数に持ち上げた(lift)ものを返す関数

一見違うことをやっているように見えるがどちらも正しい。1, 2それぞれの例を以下に示してみる。

```
// 1 Maybe a型のJust 3を(*3)で写してMaybe a型の結果を得る
*Main> fmap (*3) (Just 3)
Just 9

// 2 一引数関数に対してfmapを適用することによってf a -> f bのようにファンクター値をとってファンクター値を返す関数を返している(lift)。
*Main> :t fmap (*3)
fmap (*3) :: (Num b, Functor f) => f b -> f b
```

### ファンクター則
Functorのインスタンスはファンクター則を満たしていなければならない。  
第一法則及び第二法則があるのでそれを紹介する。

#### 第一法則
第一法則は**idでファンクター値を写した場合、ファンクター値が変化してはいけない**というものである。つまり`fmap id = id`が成り立てば良い。  
idは恒等写像、つまり引数をそのまま返す関数である([参考](http://tau.doshisha.ac.jp/lectures/2009.calculus-I/html.dir/node15.html))。  

この第一法則が満たされているかいくつかのファンクター値を使って確認してみる。
```
*Main> fmap id [1..10]
[1,2,3,4,5,6,7,8,9,10]

*Main> fmap id $ Just "hoge"
Just "hoge"

*Main> fmap id $ Right 10
Right 10

*Main> fmap id (*2) $ 2
4

*Main> fmap id getLine
10   <- 入力
"10" <- 出力
```

[]、Maybe、Either a、IO a、((->) a)は全て第一法則を満たしていそうである。  
ここでそれぞれのインスタンスのfmapの定義を見てみることにする。

```
fmapFunction :: (a -> b) -> (r -> a) -> (r -> b)
fmapFunction f g = \x -> f (g x)

fmapIO' :: (a -> b) -> IO a -> IO b
fmapIO' f action = do
  result <- action
  return (f result)

fmapList :: (a -> b) -> [a] -> [b]
fmapList f [] = []
fmapList f (x:xs) = f x : fmapList f xs

fmapMaybe :: (a -> b) -> Maybe a -> Maybe b
fmapMaybe f Nothing = Nothing
fmapMaybe f (Just x) = Just (f x)
```

引数fに全てidを当てはめて考えると確かに第一法則を満たすことがわかる。

#### 第二法則
第二法則は**二つの関数fとgについて「fとgの合成関数でファンクター値に写したもの」と「まずg、次にfでファンクター値を写したもの」が等しい**ことが必要である。  
どういうことか式で表すと、`fmap (f . g) x = fmap f (fmap g x)`となる。

第二法則を満たしているかどうかも実装を見て確認することができる。  
例えばMaybeについて。  
まずNothingについてだがfmap (f . g) Nothing及びfmap f (fmap g Nothing)の結果は当然両方ともNothingになる。  
次にJust xについて考える。  
fmap (f . g) Just xは実装からJust ((f . g) x)、つまりJust (f (g x))となる。  
fmap f (fmap g (Just x))はまずfmap g (Just x)について見てみるとJust (g x)となる。そしてfmap f (Just (g x))はJust (f (g x))となり同じ値となる。  

このことからMaybeはファンクター第二法則を満たすことが確認された。
仮にファンクター則が守られない場合はfmapで写した結果が思うような結果にならないバグを生み出す危険がある。  

そのためファンクターのインスタンスを作る場合は必ずファンクター則を満たしてなければならない。逆に満たしてさえいればfmapで写した結果は必ず正しいことが圏論的に(?)保証されている。  

### アプリカティブファンクターを使おう
今まではファンクター値を写すためにfmapに1引数関数を使ってきた。  
それでは2引数関数で写すと何が起こるのだろうか？  
例えばJust 3を(\*)で写してみると以下のようになる。

```
// showで表示できないので型のみで確認する
*Main> :t fmap (*) $ Just 3
fmap (*) $ Just 3 :: Num a => Maybe (a -> a)
```
Maybe (a -> a)という型が得られたことがわかる。  
これは二引数関数に対してJustのもつ値を一つめの引数とした結果をJustで保持していると考えることができるため実質はJust ((\*) 3)となっていると考えられる。  
このことからJustの中には関数を入れてしまうこともできる。もちろんリストやRightの中にも入れることができる。


```
// リスト
*Main> :t fmap (*) [1,2,3,4,5]
fmap (*) [1,2,3,4,5] :: Num a => [a -> a]
*Main> :t fmap (++) ["hoge", "fuga", "piyo"]
fmap (++) ["hoge", "fuga", "piyo"] :: [[Char] -> [Char]]

// Right
*Main> :t fmap (+) $ Right 10
fmap (+) $ Right 10 :: Num a1 => Either a2 (a1 -> a1)
```

#### Applicativeちゃんと仲良くしてあげてね！
リスト等のファンクターに入った関数を使う方法は一旦置いておいてまずはApplicative型クラスについての紹介をする。  
Applicative型クラスは2つの関数pureと<\*>を定義している。以下はクラス定義となる。

```
class (Functor f) => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
```

この3行から多くのことがわかる。  
まずfについてだが(Functor f)と型クラス制約がついている。これによりApplicative型クラスのインスタンスであるにはFunctor型クラスのインスタンスでなければならないことがわかる。そしてこのことからApplicative値はfmapで写すことができるということがわかる。   

次にpure関数。これは何かしらの型の引数を一つとりアプリカティブ値に包んで返すと解釈できる。  
どのようなアプリカティブ値に包むかはその時のcontext(文脈)による。returnにかなり近い。

最後の(<\*>)(読み方不明)だが型宣言は`f (a -> b) -> f a -> f b`となっている。  
f (a -> b)だがこれは先ほど紹介したファンクター値に1引数関数を入れたものであるとわかる(Just ((\*) 2))や[(\*) 2, (\*) 3]など)。  
解釈としてはfに包まれた1引数関数をfに包まれた値に適用し、得られた結果をfに包んで返すとできる。  

#### Maybeはアプリカティブファンクター
MaybeのApplicativeのインスタンス宣言を見てみる。

```
instance Applicative Maybe where
  pure = Just
  Nothing <*> _ = Nothing
  (Just f) <*> something = fmap f something
```
まずはpureについて。  
pureは文脈に乗っ取った型を返す。文脈がMaybe aだったら引数の型に応じてMaybe IntやMaybe Char等の型で値を返す。  

次に<\*>について。
第二引数のアプリカティブ(Just)に包まれた値に第一引数のアプリカティブ(Just)に包まれた関数を適用して得られた値を同じアプリカティブに包んで返す。  
以下使い方例。

```
*Main> Just (+10) <*> Just 10
Just 20
*Main> pure (+3) <*> Just 1
Just 4
*Main> Nothing <*> Just 20
Nothing
*Main> Just (*2) <*> Nothing
Nothing
```

#### アプリカティブスタイル
Applicative型クラスでは<\*>を連続して使うことができ、1つだけでなく複数のアプリカティブ値を組み合わせて使うことができる。

```
*Main> pure (+) <*> Just 10 <*> Just 20
Just 30
*Main> pure max <*> Just 10 <*> Just 20
Just 20

// 順を追って見てみる
*Main> :t pure max
pure max :: (Ord a, Applicative f) => f (a -> a -> a)
*Main> :t pure max <*> Just 10
pure max <*> Just 10 :: (Num a, Ord a) => Maybe (a -> a)
*Main> :t pure max <*> Just 10 <*> Just 20
Just 20
```

アプリカティブスタイルを理解して使うためのポイントは以下等式が成り立つという事実を考慮することである。

```
pure f <*> x == fmap f x
```

ちなみにこれは後ほどで紹介するアプリカティブ則の一つである。  
アプリカティブ値を二引数以上の関数でfmapしてからアプリカティブスタイルで文脈をつなげていくことは頻出するため、<$>という演算子が用意されている。これはfmapと同じ。  

```
// <$>とfmapが同じであることを確認する簡単な例
*Main> max <$> Just 10 <*> Just 20
Just 20
*Main> (fmap max $ Just 10) <*> Just 20
Just 20
```

#### リスト
アプリカティブのインスタンスはもちろんMaybeだけでない。リストもその一つとなる。  
以下はリストのインスタンス宣言。

```
instance Applicative [] where
pure x = [x]
fs <*> xs = [f x | f <- fs, x <- xs]
```

pureは文脈に沿った値を返すのでこの場合は[]に包んで返す。  
<\*>は右辺のリストに入ったそれぞれの値に左辺のリストの中に入った関数をそれぞれ適用する。  
左辺と右辺のリストに内包されるあらゆる関数・値を組み合わせるためにリスト内包表記によって実装されている。

```
*Main> [(*2), (+3), (^4)] <*> [1..5]
[2,4,6,8,10,4,5,6,7,8,1,16,81,256,625]

*Main> (+) <$> [2,3,4] <*> [5,6,7]
[7,8,9,8,9,10,9,10,11]

*Main> [(+), (*), (^)] <*> [2,3,4] <*> [5,6,7]
[7,8,9,8,9,10,9,10,11,10,12,14,15,18,21,20,24,28,32,64,128,243,729,2187,1024,4096,16384]
```

アプリカティブスタイルをリストに使うとリスト内包表記をうまく置き換えられることが多々ある。  
例えば第一章で[2,5,10]と[8,10,11]の積として可能な値を全て求めたいという例題があったのでこれをアプリカティブスタイルで表現してみる。

```
// リスト内包表記
*Main> [x*y | x <- [2,5,10], y <- [8,10,11]]
[16,20,22,40,50,55,80,100,110]

// アプリカティブスタイル
*Main> (*) <$> [2,5,10] <*> [8,10,11]
[16,20,22,40,50,55,80,100,110]
```

同じことをやっているのでどちらで表現しても良い。個人的な感覚になってしまうがアプリカティブスタイルの方が**写していく**という感覚で直感的に書ける気がする。

#### IOもアプリカティブファンクターだよ！
IOだってApplicative。
```
instance Applicative IO where
  pure = return
  a <*> b = do
    f <- a
    x <- b
    return (f x)
```

fmapの時は写す関数はI/Oアクションではなかったため特に束縛はしてなかったが、<\*>は写す関数もI/Oアクションであるため一旦変数に束縛し、右辺のI/Oアクションの結果も別の変数に束縛してからそれぞれ変数に束縛された値を関数に適用してreturnでIOに包んで返す。

```
*Main> (++) <$> getLine <*> getLine
hoge       <- 入力
fuga       <- 入力
"hogefuga" <- 出力
```

#### Zipリスト
リストをアプリカティブファンクターにする方法は複数ある。  
1つ目の方法はすでに紹介した通り全ての組み合わせをリストに格納することである。例えば[(+3), (\*2)]で[2, 3]を写す場合の結果は全ての組み合わせの4通りがリストに格納される。  

もう一つの方法としては対応する要素の組み合わせだけを格納するというものである。  
上記の例の場合だと(+3)と2及び(\*2)及び3の組み合わせになり[5, 6]が結果として出力されるものである。  
このやり方に対応するインスタンスとしてControl.Applicativeモジュールが提供する`ZipList a`という型がある。以下はApplicativeのインスタンスとしての定義

```
instance Applicative ZipList where
  pure x = ZipList (repeat x)
  fs <*> xs = ZipList (zipWith (\f x -> f x) fs xs)
```

pureの定義をみると受け取った引数を無限回返す。一見おかしいように感じられるが文脈に沿った形にするために必要。以下は具体例となる。  

```
*Main> getZipList $ (*) <$> ZipList [1..10] <*> ZipList [1..10]
[1,4,9,16,25,36,49,64,81,100]

// pureで上記の式を再現
*Main> getZipList $ pure (*) <*> ZipList [1..10] <*> ZipList [1..10]
[1,4,9,16,25,36,49,64,81,100]
```

pureが無限リストを返す理由は上記の式からわかる。  
もし無限リストでなかった場合上記の式は

```
getZipList $ [(*)] <*> ZipList [1..10] <*> ZipList [1..10]
```

となってしまい結果は[1]となる。  
pureによってZipListの文脈に合わせるためには無限リストを返すことで他のZipListの持つ要素数の最小値を表現することができる。  

ちなみにすごいH本ではZipList a型はShowインスタンスをサポートしてないと述べているが、これはおそらく2012年頃の話で今はサポートしている。  

#### アプリカティブ則
以下の式はアプリカティブ則を満たすための条件である。  
本でも述べられていなかったのでここではとくに証明については触れない。紹介だけ。

* `pure id <*> v = v`
* `pure (.) <*> u <*> v <*> w = u <*> (v <*> w)`
* `pure f <*> pure x = pure (f x)`
* `u <*> pure y = pure ($ y) <*> u`
