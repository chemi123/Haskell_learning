# すごいHな勉強会
## 第十三章 - モナドがいっぱい
### アプリカティブファンクターを強化する
まずは復習から。  
ファンクターを導入した動機はfをFunctorとした場合
1. (a -> b)型の関数を(f a -> f b)にリフトさせる
2. (a -> b)型の関数でf aをf bに写す  

の二つであった。  

では仮にfに(a -> b)型の関数が包まれていた場合どのようにすれば良いのだろうか？  
例えばJust (\*2)があったとして、それをJust 5に適用するには？他にもJust 5がNothingに変わったら？Maybe a型ではなくリストの[(\*2), (+4)]があったとして、それを[1, 2, 3]に適用するには？  
これらを解決するために、Funtor型クラスをさらに改良したApplicative型クラスが導入された。

```
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b
```

(<\*>)を使うことによってJust (\*2)をJust 5に適用することができるようになった。  
またpureではどのような型でも文脈に応じてアプリカティブインスタンス型に入れる操作が可能となった。1を[1]にしたりJust 1にしたりする操作のことである。  

ここでモナドはある要望を叶えるためにアプリカティブ値が自然に拡張された。  
その要望とは「普通の値aを取って文脈付きの値を返す関数に、文脈付きの値m aを渡したい」というものである。言い換えると、a -> m b型の関数をm a型の値に適用したいと言うことである。つまりは以下の関数が欲しいということになる。

```
(>>=) :: (Monad m) => m a -> (a -> m b) -> m a
```

(>>=)は**バインド**と読む。mはMonadの頭文字。
モナドは(>>=)をサポートするアプリカティブファンクターにすぎない。  
普通の値aを普通の関数(a -> b)に食わせるのは簡単。では文脈付きの値m aを普通の値をとってm aを返す関数に食わせるにはどうすれば良いのであろうか？  
この章ではそのやり方について見ていくことにする。

### Maybeから始めるモナド
ここからはファンクターとアプリカティブファンクターを少し振り返ってからモナドの具体例を見ていく。まずはMaybe。  
Maybe a型の値はa型の値を示しているが、Maybeに包まれることで同時に失敗する可能性という文脈が付いている。例えばJust "hoge"は文字列"hoge"がそこに実在することを意味するが、Nothingという値は"無"又は計算が失敗したということを意味する。  
ファンクターとして見たMaybeに対して関数をfmapするとJust値であれば中身に関数を適用するがNothingであればNothingを返す。  
```
Prelude> fmap (+1) $Just 1
Just 2
Prelude> fmap (+1) Nothing
Nothing
```

アプリカティブファンクターとしてののMaybeの機能も似たようなものになる。  
ただしアプリカティブファンクターになると値だけではなく値に適用する関数にも文脈がつく。つまりJust (\*2)のようにMaybe a型であれば関数がJustに包まれる。
関数又は値がNothingなら結果もNothingになるので失敗が伝搬する。

```
*Main> Just (*2) <*> Just 2
Just 4
*Main> Nothing  <*> Just 2
Nothing

// アプリカティブスタイル
*Main> (*) <$> Just 2 <*> Just 4
Just 8
*Main> (*) <$> Nothing  <*> Just 4
Nothing
```

それではいよいよMaybeにとっての>>=をどう定義すればよいか考えてみる。  
\>>=は「モナド値」と「普通の値を取ってモナド値を返す関数」を引数にとり、モナド値を返す関数である。  
「普通の値を取ってモナド値を返す関数」とは具体的には例えば\x -> Just (x+1)などがある。これは普通の値xをとって1を足してからJustに包んで返す関数である。ではこれをどうしたらMaybe a型に適用することができるのであろうか？  

この答えは割と簡単でパターンマッチを使えばできる。  
NothingならNothingを返し、Just値ならJustの中身を取り出してそれを関数に適用すれば良い。  
一旦>>=のと呼ぶのはやめてapplyMaybeという名前で関数を作ることを考える。  
Maybe a型に具体化された場合「Maybe a型の値」と「普通の値を取ってMaybe b型の値をとる関数」を引数にとってMaybe a型の値を返すように定義してやれば良い。  

```
applyMaybe :: Maybe a -> (a -> Maybe b) - Maybe b
applyMaybe Nothing f = Nothing
applyMaybe (Just x) f = f x
```

これは>>=をMaybeに具体化した関数である。早速使ってみる。

```
*Main> Just 10 `applyMaybe` \x -> Just (x+1)
Just 11
*Main> Nothing `applyMaybe` \x -> Just (x+1)
Nothing
```

このapplyMaybeによって「モナド値」に「普通の値を取ってモナド値を返す関数」を適用する方法が見えてきた。  
ではそれの何が便利なのであろうか？それをこれから見ていくことにする。

### Monad型クラス
Monadの型クラスを紹介する。以下は定義。

```
class Applicative m =>  Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  fail :: String -> m a
```

モナドはアプリカティブファンクターの強化版なのでApplicative型クラス制約がつく。  
最小完全定義は>>=なのでそれさえ定義してしまえばMonad型クラスのインスタンスになる。  
returnは通常の値を受けとってモナド型クラスのインスタンスに包んで返す。  
\>>=は「モナド値」及び「通常の値を取ってモナド値を返す関数」を取りモナド値を返す。  
\>>及びfailnについては一旦は気にしない。以下にMaybeのMonadインスタンス定義を示す。

```
instance Monad Maybe where
  return x = Just x
  Nothing >>= f = Nothing
  Just x >>= f = f x
  fail _ = Nothing
```

returnはpureと全く同じ動作を、>>=は先ほど定義したapplyMaybeと同じ動作をする。

```
*Main> return 10 :: Maybe Int
Just 10
*Main> return 10 >>= \x -> Just (x+1)
Just 11
*Main> return 10 >>= \x -> Just (x+1) >>= \x -> Just (x^2)
Just 121

// 失敗は伝搬する
*Main> Nothing >>= \x -> return (x+10)
Nothing
*Main> Nothing >>= \x -> Just (x+1) >>= \x -> Just (x^2)
Nothing
```

### 綱渡り
失敗するかもしれない計算が文脈を損なうことなくMaybe a型の値にa -> Maybe b型の関数を適用する方法がわかったので>>=を繰り返し使ってMaybe a型を返す複数の計算を扱う例を見ていく。  

ピエールが綱渡りをする際、持っているバランス棒に鳥がとまってしまう問題がある。左右バランスよくとまる分には問題ないが偏ってしまうとピエールは転落してしまう。  
棒の左右にとまる鳥の数の差が3以内であれば問題ないがそれより多いとピエールは転落する。  

では鳥たちバランス棒の左右の端に飛んできたり飛び去ったりする様子をシミュレートして一定数の取りたちが来たり去ったりしたあともピエールが綱の上にいるかどうかを判定するプログラムを書いてみる。  

#### ひたすらコーデョイング
まずは鳥の数及び左右の鳥の数を表現する型を型シノニムで定義する。

```
type Birds = Int
type Pole = (Birds, Birds)
```

次に左及び右に鳥がとまった後に棒の状態を返す関数をそれぞれ定義する。  
ただし左右の鳥の数の差が3より大きくなったら失敗(ピエールが落ちる)する。

```
landLeft :: Birds -> Pole -> Maybe Pole
landLeft n (left, right) = (left + n, right)

landRight:: Birds -> Pole -> Maybe Pole
landRight n (left, right) = (left, right + n)
```

これにより左右の鳥の数の差が4以上になったら失敗する

```
// 成功
*Main> landLeft 3 (0, 0)
Just (3,0)
*Main> landRight 3 (0, 0)
Just (0,3)

// 失敗
*Main> landLeft 4 (0, 0)
Nothing
*Main> landRight 4 (0, 0)
Nothing
```

これは初期状態(0, 0)から次の瞬間鳥がどちらかにとまった後を表しているにすぎない。  
では仮に次の順番で鳥が行ったり来たりした後に果たしてピエールはロープの上に留まり続けているのであろうか？

1. ピエールが網の上に立つ(鳥はまだ来てない)
2. 左に鳥が2羽来る
3. 右に鳥が3羽来る
4. 左から鳥が1羽飛ぶ
5. 右に鳥が1羽来る

これを計算するために>>=を使うことができる。  
失敗(Nothing)は伝搬するため、計算の結果出力された値がNothingであれば失敗(ピエールが転落)しており、Just値が帰ってきたらピエールは綱の上に留まって入られたことになる。早速やってみる。

```
*Main> return (0, 0) >>= landLeft 2 >>= landRight 3 >>= landLeft (-1) >>= landRight 1
Just (1,4)
```

最後にJust値が返ってきたのでピエールは網の上に留まり続けることができたということになる。  
ではこれは何が起きたのか順を追って説明する。

1. ピエールが網の上に立った初期状態(0, 0)を>>=の文脈に入れるためにreturnでJustに包む(型指定をしなくても計算の文脈でよろしくMaybe a型だとよろしく解釈してくれる)
2. Just (0, 0) >> landLeft 2が評価される。landLeft 2は引数を一つとることでカリー化されPole -> Maybe Poleを返す一引数関数となり、>>=の性質によりJust (0, 0)を処理される
3. このタイミングでJust (2, 0)となっておりまだ差は4より小さい。そしてこの値をそのまま2と同じようにlandRight 3に食わせる
4. Just (2, 3)となっている。同じくlandLeft (-1)に食わせる
5. Just (1, 3)であり、landRight 1に食わせる

上記1~5の手順を踏むことで最終的に得られる結果はJust (1, 4)となる。  
最終的な結果もそうであるが、途中結果でも一回も左右の鳥の数の差が4以上になることはなかった。そのためこの計算は成功でピエールが綱の上から落ちることはなかった。  

では3番目の手順で鳥が6羽来た場合はどうなるのであろうか？

```
*Main> return (0, 0) >>= landLeft 2 >>= landRight 6 >>= landLeft (-1) >>= landRight 1
Nothing
```

予想は大方つくがNothingが返っている。  
これは計算が途中で失敗してピエールが落ちたことを意味している。  

このように>>=を使うことである意味で状態を保持しながらその値を連続して使っていくことができることがわかった。

#### ロープの上のバナナ
