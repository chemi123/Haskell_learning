# すごいHな勉強会
## 第十三章 - モナドがいっぱい
### アプリカティブファンクターを強化する
まずは復習から。  
ファンクターを導入した動機はfをFunctorとした場合
1. (a -> b)型の関数を(f a -> f b)にリフトさせる
2. (a -> b)型の関数でf aをf bに写す  

の二つであった。  

では仮にfに(a -> b)型の関数が包まれていた場合どのようにすれば良いのだろうか？  
例えばJust (\*2)があったとして、それをJust 5に適用するには？他にもJust 5がNothingに変わったら？Maybe a型ではなくリストの[(\*2), (+4)]があったとして、それを[1, 2, 3]に適用するには？  
これらを解決するために、Funtor型クラスをさらに改良したApplicative型クラスが導入された。

```
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b
```

(<\*>)を使うことによってJust (\*2)をJust 5に適用することができるようになった。  
またpureではどのような型でも文脈に応じてアプリカティブインスタンス型に入れる操作が可能となった。1を[1]にしたりJust 1にしたりする操作のことである。  

ここでモナドはある要望を叶えるためにアプリカティブ値が自然に拡張された。  
その要望とは「普通の値aを取って文脈付きの値を返す関数に、文脈付きの値m aを渡したい」というものである。言い換えると、a -> m b型の関数をm a型の値に適用したいと言うことである。つまりは以下の関数が欲しいということになる。

```
(>>=) :: (Monad m) => m a -> (a -> m b) -> m a
```

(>>=)は**バインド**と読む。mはMonadの頭文字。
モナドは(>>=)をサポートするアプリカティブファンクターにすぎない。  
普通の値aを普通の関数(a -> b)に食わせるのは簡単。では文脈付きの値m aを普通の値をとってm aを返す関数に食わせるにはどうすれば良いのであろうか？  
この章ではそのやり方について見ていくことにする。

### Maybeから始めるモナド
ここからはファンクターとアプリカティブファンクターを少し振り返ってからモナドの具体例を見ていく。まずはMaybe。  
Maybe a型の値はa型の値を示しているが、Maybeに包まれることで同時に失敗する可能性という文脈が付いている。例えばJust "hoge"は文字列"hoge"がそこに実在することを意味するが、Nothingという値は"無"又は計算が失敗したということを意味する。  
ファンクターとして見たMaybeに対して関数をfmapするとJust値であれば中身に関数を適用するがNothingであればNothingを返す。  
```
Prelude> fmap (+1) $Just 1
Just 2
Prelude> fmap (+1) Nothing
Nothing
```

アプリカティブファンクターとしてののMaybeの機能も似たようなものになる。  
ただしアプリカティブファンクターになると値だけではなく値に適用する関数にも文脈がつく。つまりJust (\*2)のようにMaybe a型であれば関数がJustに包まれる。
関数又は値がNothingなら結果もNothingになるので失敗が伝搬する。

```
*Main> Just (*2) <*> Just 2
Just 4
*Main> Nothing  <*> Just 2
Nothing

// アプリカティブスタイル
*Main> (*) <$> Just 2 <*> Just 4
Just 8
*Main> (*) <$> Nothing  <*> Just 4
Nothing
```

それではいよいよMaybeにとっての>>=をどう定義すればよいか考えてみる。  
\>>=は「モナド値」と「普通の値を取ってモナド値を返す関数」を引数にとり、モナド値を返す関数である。  
「普通の値を取ってモナド値を返す関数」とは具体的には例えば\x -> Just (x+1)などがある。これは普通の値xをとって1を足してからJustに包んで返す関数である。ではこれをどうしたらMaybe a型に適用することができるのであろうか？  

この答えは割と簡単でパターンマッチを使えばできる。  
NothingならNothingを返し、Just値ならJustの中身を取り出してそれを関数に適用すれば良い。  
一旦>>=のと呼ぶのはやめてapplyMaybeという名前で関数を作ることを考える。  
Maybe a型に具体化された場合「Maybe a型の値」と「普通の値を取ってMaybe b型の値をとる関数」を引数にとってMaybe a型の値を返すように定義してやれば良い。  

```
applyMaybe :: Maybe a -> (a -> Maybe b) - Maybe b
applyMaybe Nothing f = Nothing
applyMaybe (Just x) f = f x
```

これは>>=をMaybeに具体化した関数である。早速使ってみる。

```
*Main> Just 10 `applyMaybe` \x -> Just (x+1)
Just 11
*Main> Nothing `applyMaybe` \x -> Just (x+1)
Nothing
```

このapplyMaybeによって「モナド値」に「普通の値を取ってモナド値を返す関数」を適用する方法が見えてきた。  
ではそれの何が便利なのであろうか？それをこれから見ていくことにする。

### Monad型クラス
Monadの型クラスを紹介する。以下は定義。

```
class Applicative m =>  Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  fail :: String -> m a
```

モナドはアプリカティブファンクターの強化版なのでApplicative型クラス制約がつく。  
最小完全定義は>>=なのでそれさえ定義してしまえばMonad型クラスのインスタンスになる。  
returnは通常の値を受けとってモナド型クラスのインスタンスに包んで返す。  
\>>=は「モナド値」及び「通常の値を取ってモナド値を返す関数」を取りモナド値を返す。  
\>>及びfailnについては一旦は気にしない。以下にMaybeのMonadインスタンス定義を示す。

```
instance Monad Maybe where
  return x = Just x
  Nothing >>= f = Nothing
  Just x >>= f = f x
  fail _ = Nothing
```

returnはpureと全く同じ動作を、>>=は先ほど定義したapplyMaybeと同じ動作をする。

### 綱渡り
