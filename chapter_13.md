# すごいHな勉強会
## 第十三章 - モナドがいっぱい
### アプリカティブファンクターを強化する
まずは復習から。  
ファンクターを導入した動機はfをFunctorとした場合
1. (a -> b)型の関数を(f a -> f b)にリフトさせる
2. (a -> b)型の関数でf aをf bに写す  

の二つであった。  

では仮にfに(a -> b)型の関数が包まれていた場合どのようにすれば良いのだろうか？  
例えばJust (\*2)があったとして、それをJust 5に適用するには？他にもJust 5がNothingに変わったら？Maybe a型ではなくリストの[(\*2), (+4)]があったとして、それを[1, 2, 3]に適用するには？  
これらを解決するために、Funtor型クラスをさらに改良したApplicative型クラスが導入された。

```
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b
```

(<\*>)を使うことによってJust (\*2)をJust 5に適用することができるようになった。  
またpureではどのような型でも文脈に応じてアプリカティブインスタンス型に入れる操作が可能となった。1を[1]にしたりJust 1にしたりする操作のことである。  

ここでモナドはある要望を叶えるためにアプリカティブ値が自然に拡張された。  
その要望とは「普通の値aを取って文脈付きの値を返す関数に、文脈付きの値m aを渡したい」というものである。言い換えると、a -> m b型の関数をm a型の値に適用したいと言うことである。つまりは以下の関数が欲しいということになる。

```
(>>=) :: (Monad m) => m a -> (a -> m b) -> m a
```

(>>=)は**バインド**と読む。mはMonadの頭文字。
モナドは(>>=)をサポートするアプリカティブファンクターにすぎない。  
普通の値aを普通の関数(a -> b)に食わせるのは簡単。では文脈付きの値m aを普通の値をとってm aを返す関数に食わせるにはどうすれば良いのであろうか？  
この章ではそのやり方について見ていくことにする。

### Maybeから始めるモナド
ここからはファンクターとアプリカティブファンクターを少し振り返ってからモナドの具体例を見ていく。まずはMaybe。  
Maybe a型の値はa型の値を示しているが、Maybeに包まれることで同時に失敗する可能性という文脈が付いている。例えばJust "hoge"は文字列"hoge"がそこに実在することを意味するが、Nothingという値は"無"又は計算が失敗したということを意味する。  
ファンクターとして見たMaybeに対して関数をfmapするとJust値であれば中身に関数を適用するがNothingであればNothingを返す。  
```
Prelude> fmap (+1) $Just 1
Just 2
Prelude> fmap (+1) Nothing
Nothing
```

アプリカティブファンクターとしてののMaybeの機能も似たようなものになる。  
ただしアプリカティブファンクターになると値だけではなく値に適用する関数にも文脈がつく。つまりJust (\*2)のようにMaybe a型であれば関数がJustに包まれる。
関数又は値がNothingなら結果もNothingになるので失敗が伝搬する。

```
*Main> Just (*2) <*> Just 2
Just 4
*Main> Nothing  <*> Just 2
Nothing

// アプリカティブスタイル
*Main> (*) <$> Just 2 <*> Just 4
Just 8
*Main> (*) <$> Nothing  <*> Just 4
Nothing
```

それではいよいよMaybeにとっての>>=をどう定義すればよいか考えてみる。  
\>>=は「モナド値」と「普通の値を取ってモナド値を返す関数」を引数にとり、モナド値を返す関数である。  
「普通の値を取ってモナド値を返す関数」とは具体的には例えば\x -> Just (x+1)などがある。これは普通の値xをとって1を足してからJustに包んで返す関数である。ではこれをどうしたらMaybe a型に適用することができるのであろうか？  

この答えは割と簡単でパターンマッチを使えばできる。  
NothingならNothingを返し、Just値ならJustの中身を取り出してそれを関数に適用すれば良い。  
一旦>>=のと呼ぶのはやめてapplyMaybeという名前で関数を作ることを考える。  
Maybe a型に具体化された場合「Maybe a型の値」と「普通の値を取ってMaybe b型の値をとる関数」を引数にとってMaybe a型の値を返すように定義してやれば良い。  

```
applyMaybe :: Maybe a -> (a -> Maybe b) - Maybe b
applyMaybe Nothing f = Nothing
applyMaybe (Just x) f = f x
```

これは>>=をMaybeに具体化した関数である。早速使ってみる。

```
*Main> Just 10 `applyMaybe` \x -> Just (x+1)
Just 11
*Main> Nothing `applyMaybe` \x -> Just (x+1)
Nothing
```

このapplyMaybeによって「モナド値」に「普通の値を取ってモナド値を返す関数」を適用する方法が見えてきた。  
ではそれの何が便利なのであろうか？それをこれから見ていくことにする。

### Monad型クラス
Monadの型クラスを紹介する。以下は定義。

```
class Applicative m =>  Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  fail :: String -> m a
```

モナドはアプリカティブファンクターの強化版なのでApplicative型クラス制約がつく。  
最小完全定義は>>=なのでそれさえ定義してしまえばMonad型クラスのインスタンスになる。  
returnは通常の値を受けとってモナド型クラスのインスタンスに包んで返す。  
\>>=は「モナド値」及び「通常の値を取ってモナド値を返す関数」を取りモナド値を返す。  
\>>及びfailについては一旦は気にしない。以下にMaybeのMonadインスタンス定義を示す。

```
instance Monad Maybe where
  return x = Just x
  -- (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
  Nothing >>= f = Nothing
  Just x >>= f = f x
  fail _ = Nothing
```

returnはpureと全く同じ動作を、>>=は先ほど定義したapplyMaybeと同じ動作をする。

```
*Main> return 10 :: Maybe Int
Just 10
*Main> return 10 >>= \x -> Just (x+1)
Just 11
*Main> return 10 >>= \x -> Just (x+1) >>= \x -> Just (x^2)
Just 121

// 失敗は伝搬する
*Main> Nothing >>= \x -> return (x+10)
Nothing
*Main> Nothing >>= \x -> Just (x+1) >>= \x -> Just (x^2)
Nothing
```

### 綱渡り
失敗するかもしれない計算が文脈を損なうことなくMaybe a型の値にa -> Maybe b型の関数を適用する方法がわかったので>>=を繰り返し使ってMaybe a型を返す複数の計算を扱う例を見ていく。  

ピエールが綱渡りをする際、持っているバランス棒に鳥がとまってしまう問題がある。左右バランスよくとまる分には問題ないが偏ってしまうとピエールは転落してしまう。  
棒の左右にとまる鳥の数の差が3以内であれば問題ないがそれより多いとピエールは転落する。  

では鳥たちバランス棒の左右の端に飛んできたり飛び去ったりする様子をシミュレートして一定数の取りたちが来たり去ったりしたあともピエールが綱の上にいるかどうかを判定するプログラムを書いてみる。  

#### ひたすらコーデョイング
まずは鳥の数及び左右の鳥の数を表現する型を型シノニムで定義する。

```
type Birds = Int
type Pole = (Birds, Birds)
```

次に左及び右に鳥がとまった後に棒の状態を返す関数をそれぞれ定義する。  
ただし左右の鳥の数の差が3より大きくなったら失敗(ピエールが落ちる)する。

```
landLeft :: Birds -> Pole -> Maybe Pole
landLeft n (left, right)
  | abs ((left + n) - right) < 4 = Just (left + n, right)
  | otherwise                    = Nothing

landRight:: Birds -> Pole -> Maybe Pole
landRight n (left, right)
  | abs (left - abs (right + n)) < 4 = Just (left, right + n)
  | otherwise                        = Nothing
```

これにより左右の鳥の数の差が4以上になったら失敗する

```
// 成功
*Main> landLeft 3 (0, 0)
Just (3,0)
*Main> landRight 3 (0, 0)
Just (0,3)

// 失敗
*Main> landLeft 4 (0, 0)
Nothing
*Main> landRight 4 (0, 0)
Nothing
```

これは初期状態(0, 0)から次の瞬間鳥がどちらかにとまった後を表しているにすぎない。  
では仮に次の順番で鳥が行ったり来たりした後に果たしてピエールはロープの上に留まり続けているのであろうか？

1. ピエールが網の上に立つ(鳥はまだ来てない)
2. 左に鳥が2羽来る
3. 右に鳥が3羽来る
4. 左から鳥が1羽飛ぶ
5. 右に鳥が1羽来る

これを計算するために>>=を使うことができる。  
失敗(Nothing)は伝搬するため、計算の結果出力された値がNothingであれば失敗(ピエールが転落)しており、Just値が帰ってきたらピエールは綱の上に留まって入られたことになる。早速やってみる。

```
*Main> return (0, 0) >>= landLeft 2 >>= landRight 3 >>= landLeft (-1) >>= landRight 1
Just (1,4)
```

最後にJust値が返ってきたのでピエールは網の上に留まり続けることができたということになる。  
ではこれは何が起きたのか順を追って説明する。

1. ピエールが網の上に立った初期状態(0, 0)を>>=の文脈に入れるためにreturnでJustに包む(型指定をしなくても計算の文脈でよろしくMaybe a型だとよろしく解釈してくれる)
2. Just (0, 0) >>= landLeft 2が評価される。landLeft 2は引数を一つとることでカリー化されPole -> Maybe Poleを返す一引数関数となり、>>=の性質によりJust (0, 0)を処理される
3. このタイミングでJust (2, 0)となっておりまだ差は4より小さい。そしてこの値をそのまま2と同じようにlandRight 3に食わせる
4. Just (2, 3)となっている。同じくlandLeft (-1)に食わせる
5. Just (1, 3)であり、landRight 1に食わせる

上記1~5の手順を踏むことで最終的に得られる結果はJust (1, 4)となる。  
最終的な結果もそうであるが、途中結果でも一回も左右の鳥の数の差が4以上になることはなかった。そのためこの計算は成功でピエールが綱の上から落ちることはなかった。  

では3番目の手順で鳥が6羽来た場合はどうなるのであろうか？

```
*Main> return (0, 0) >>= landLeft 2 >>= landRight 6 >>= landLeft (-1) >>= landRight 1
Nothing
```

予想は大方つくがNothingが返っている。  
これは計算が途中で失敗してピエールが落ちたことを意味している。  

このように>>=を使うことである意味で状態を保持しながらその値を連続して使っていくことができることがわかった。

#### ロープの上のバナナ
今度は左右の鳥の数の差に関わらずピエールが失敗する関数を作ってみる。  
綱の上にバナナがあれば誰だって落ちる。

```
banana :: Pole -> Maybe Pole
banana _ = Nothing
```

これをピエールが網の上に留まっていられる例の真ん中にはさんでみる。

```
*Main> return (0, 0) >>= landLeft 2 >>= banana >>= landRight 3 >>= landLeft (-1) >>= landRight 1
Nothing
```

予想通りNothingの結果が得られた。  
ちなみに入力に関係なく既定のモナド値を返す関数であれば自作しなくても>>を使えば良い。以下に>>のデフォルト実装を示す。

```
(>>) :: m a -> m b
m >> n = \_ -> n
```

普通の関数であれば引数を無視して既定の値を返す関数の結果はその既定値そのものになるが、モナド値を扱う場合はモナドとしての文脈を考慮する必要がある(通常は規定値を扱うが失敗ならNothingを返すという意味)。早速使ってみる。

```
*Main> Nothing >> Just 10
Nothing
*Main> Just 3 >> Just 4
Just 4
*Main> Just 3 >> Nothing
Nothing
```

先ほどのbananaを挿入した部分と同じところで>>に入れ替えてみる。

```
*Main> return (0, 0) >>= landLeft 2 >> Nothing >>= landRight 3 >>= landLeft (-1) >>= landRight 1
Nothing
```

期待通りの結果が得られた。  
ところでもしMaybeを失敗の文脈がついた値をして>>=に食わせて計算していくという方法を取らなければかなり面倒くさいコードになっていることが想像できる。詳細は割愛する。  

この節では関数適用を>>=にしてモナド値(ここではMaybe a型の値)に適用していくだけで簡単に失敗を処理するやり方を組み込むことができた。  
これは>>=が関数を値に適用するにあたり、値が持っている文脈を保存することができるからである。  
Maybe値に関数を適用すると常にしっぱの可能性が考慮されたコードが出来上がる。  

ちなみに失敗の可能性を考慮し、失敗した場合に何が原因で失敗したかを詳しく知りたい場合はEither a b型を使えば解決できる。これは宿題。

### do記法
モナドは便利なのでモナド専用構文まで用意されている。それはdo記法。  
IOの章で複数のI/Oアクションを糊付けする際に使ったが、実はdo記法はIOモナドだけではなくあらゆるモナドに使うことができる。使い方はI/Oを糊付けする際のやり方と同じで複数のモナド値を糊付けするものである。  

do記法を扱う前に次の例を見てみる。

```
*Main> Just 3 >>= \x -> Just (show x ++ "!")
Just "3!"
```

これは簡単。では次の例はどうだろうか？

```
*Main> Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))
Just "3!"
```

入れ子構造になっている。  
これはxに最初のJust 3の3が入り、yにはJust "!"の"!"が入っていることがわかる。  
これをよく見るとxに3を束縛し、yに"!"を束縛しているように見える。実際do記法を使うことで以下のように表現することができる。

```
foo :: Maybe String
foo = do
  x <- Just 3
  y <- Just "!"
  Just (show x ++ y)
```

I/Oアクションにおけるdo記法の場合<-は例えばIO String型のI/Oアクションの実行結果として得られるStringの値を変数に束縛していた。  
この場合はMaybe StringのString値を変数に束縛している。最後はfooが返す型(Maybe String)で終了している。  

このようにdo記法を使うことで>>=で連鎖的に記述される処理を手続き的に記述することができる。失敗は伝搬するため、以下のように記述すればもちろん結果はNothingになる。

```
foo :: Maybe String
foo = do
  x <- Just 3
  y <- Just "!"
  Nothing
  Just (show x ++ y)
```

#### do自由自在
do式はlet行を除きすべてモナド値で構成される。モナドの結果を調べるには<-を使う。例えば、変数を<-でMaybe Stringの結果に束縛するならその変数はStringとなる。これは>>=を使ってモナド値をラムダ式に食わせた時と全く同じである。  

do式の最後のモナド値だけは<-で結果を束縛することはできない。その理由は最後のモナドで<-を使ってもそれを受けるラムダ式が存在しないためである。

```
*Main> Just 10 >>= \x -> Just (x+1)
Just 11
```

上の例で考えてみるとJust 10に食わせる関数が\x -> Just (x+1)とあるのでx <- 10とすることができるが、その結果のJust 11に対して食わせる関数はもうない。  
do記法もこれと同じで最後に束縛して終わらせようと思ってもその結果を食わせる関数が存在しないためエラーとなる。

#### 帰ってきたピエール
ピエールの綱渡りの動作ももちろんdo記法を使って表現することができる。
例えばうまくいった以下の例をdo記法で示してみる。

```
// >>=で結合した場合
*Main> return (0, 0) >>= landLeft 2 >>= landRight 3 >>= landLeft (-1) >>= landRight 1

// do記法で記述した場合
pierrSucceed :: Maybe Pole
pierrSucceed = do
  start <- return (0, 0)
  first <- landLeft 2 start
  second <- landRight 3 first
  third <- landLeft (-1) second
  landRight 1 third
```

途中でバナナを踏ませることもできる。

```
pierrFail :: Maybe Pole
pierrFail = do
  start <- return (0, 0)
  first <- landLeft 2 start
  second <- landRight 3 first
  Nothing
  third <- landLeft (-1) second
  landRight 1 third
```

#### パターンマッチと失敗
do記法でモナド値を変数名に束縛するときには、let式や関数の引数の時と同様にパターンマッチが使える。

```
justH :: Maybe Char
justH = do
  (x:xs) <- Just "Hello!"
  return x
```

ではこのパターンマッチが失敗したらどうなるのであろうか？  
関数のパターンマッチの場合は失敗したら次のパターンが試され、何も該当するケースがない場合は例外を出してプログラムが終了する。  

do式の中でパターンマッチが失敗した場合はMonad型クラスの一員であるfail関数が使われるためモナドの文脈に沿った形で失敗を処理することができる。以下はfailのデフォルト実装。

```
fail :: (Monad m) => String -> m a
fail msg = error msg
```

デフォルトではプログラムが異常終了する。しかしMaybeのような失敗を処理できる文脈を持つモナドでは通常は独自にfailを実装している。

```
// Maybe a型のfail
fail _ = Nothing

// [a]型のfail
fail _ = []

// 実行結果
*Main> fail "hello" :: Maybe Int
Nothing
*Main> fail "hello" :: [Int]
[]
```

これで束縛の際のパターンマッチが失敗してもプログラムがクラッシュすることがない。

```
failPatternMatch :: Maybe Char
failPatternMatch = do
  x(:xs) <- Just ""  -- この行を実質Nothingに書き換えたのと同じ
  return x
```

### リストモナド
リストもモナド型クラスのインスタンスである。  
リストのモナドを考える前にアプリカティブについて考えてみる。アプリカティブのリストは非決定的な値である。

```
*Main> (*) <$> [2,3,4] <*> [1..5]
[2,4,6,8,10,3,6,9,12,15,4,8,12,16,20]
```

このようにリストの場合は答えが一つではなく複数の計算結果を返す。  
Maybeモナドは失敗するかもしれない文脈だったのに対してリストモナドはこのような非決定性の性質を持つ。以下はリストのモナドインスタンス定義。

```
instance Monad [] where
  return x = [x]
  --(>>=) :: [a] -> (a -> [b]) -> [b]
  xs >> f = concat [map f xs]
  fail _ = []
```

returnはその時の文脈に沿った値を返すのでリストの文脈の場合はxをリストに包んで返す。  
リストの場合は>>=はリスト値及び通常の値をとってリスト値を返す関数をとってリスト値を返す関数である。  
挙動としてはリストに関数をmapした結果リストの中にリスト値が包まれる。そしてconcatで平にする。以下に例を見てみる。  

```
*Main> [1,2,3] >>= \x -> [x, -x]
[1,-1,2,-2,3,-3]
```

これはまずは[1,2,3]に対してmapで\x -> [x, -x]を適用するため[[1, -1], [2, -2], [3, -3]]という答えが得られ、それをconcatして平にしている。  

リストモナドは非決定性の性質を持つことがわかった。では以下の計算の結果はどうなるかについて考えてみよう。  

```
*Main> [1,2] >>= \n -> ['a', 'b'] >>= \ch -> return (n, ch)
```

考え方としてはまずnに1及び2が束縛され、chに'a'及び'b'が束縛される。  
そしてnとchの取り得る組み合わせを全てタプルのリストとして出力されるとなる。なので答えは以下のようになる。  

```
*Main> [1,2] >>= \n -> ['a', 'b'] >>= \ch -> return (n, ch)
[(1,'a'),(1,'b'),(2,'a'),(2,'b')]
```

分かっただろうか？もちろんこれはdo記法で表現することもできる。

```
listOfTuples :: [(Int, Char)]
listOfTuples = do
  n <- [1, 2]
  ch <- ['a', 'b']
  return (n, ch)
```

#### do記法とリスト内包表記
実は先の紹介のリストモナドの計算はリスト内包表記で表現できる。

```
*Main> [(n, ch) | n <- [1, 2], ch <- ['a', 'b']]
[(1,'a'),(1,'b'),(2,'a'),(2,'b')]
```

リスト内包表記はリストモナドの構文糖衣にすぎない。最後のreturnでリストに包むのは出力の際に自動で行ってくれている。

#### MonadPlusとguard関数
リストの内包表記では出力する要素をfilterすることができる。例えば7が含まれる数のみにfilterしたい場合は以下のように書ける。

```
*Main> [x | x <- [1..50], '7' `elem` show x]
[7,17,27,37,47]
```

ではこれはどのようなリストモナドとして翻訳されているのであろうか？  
それを理解するためにはMonadPlus及びguard関数について知る必要がある。  

MonadPlusとはモノイドの性質を併せ持つモナドを表す型クラスのことである。以下はその定義となる。

```
class (Monad m) => MonadPlus m where
  mzero :: m a
  mplus :: m a -> m a -> m a
```

mzeroはMonoid型クラスでいうところのmemptyに、mplusはmappendにあたる。  
リストはモノイドであるためMonadPlus型クラスのインスタンスになり得る。

```
instance MonadPlus [] where
  mzero = []
  mplus = (++)
```

mzeroは[]を返しmplusは(++)でリストの結合をする。モノイドの性質そのままである。  
guard関数の定義は以下のようになる。

```
guard :: (MonadPlus m) => Bool -> m ()
guard True = return ()
guard False = mzero
```

Boolを引数にとりTrueなら()を成功を表す最小限の文脈に入れ、Falseなら失敗したモナド値を作る。以下で色々試してみる。

```
*Main> guard (5 > 2) :: Maybe ()
Just ()
*Main> guard (1 > 2) :: Maybe ()
Nothing
*Main> guard (5 > 2) :: [()]
[()]
*Main> guard (1 > 2) :: [()]
[]
```

これの何が役に立つのだろうかと思うがリストモナドでguardを使って解の候補をふるい落とすことができる。

```
*Main> [1..50] >>= \x -> guard ('7' `elem` show x) >> return x
[7,17,27,37,47]
```

何が起きているかを説明する。
まずreturn xの手前までの演算だがこれだけの結果を表示すると以下のようになる。

```
*Main> [1..50] >>= \x -> guard ('7' `elem` show x)
[(),(),(),(),()]
```

guardの結果がTrueである場合は[()]が返る。この例の場合だと[7,17,27,37,47]である。そのため[[()],[()],[()],[()],[()]]が返るが>>=の定義によりconcatで平になり、その結果[(),(),(),(),()]となる。  

そしてx <- [1..50]と束縛されているため>>で[(),(),(),(),()]を対応するxに直接変換した結果[7,17,27,37,47]が返る。もちろんdo記法で表現することもできる。

```
sevensOnly :: [Int]
sevensOnly = do
  x <- [1..50]
  guard ('7' `elem` show x)
  return x
```

もう一度別の例で一連の流れを以下に示す。

```
// >>の復習。>>は左のモナド値を右のモナド値に変換する
*Main> [1..10] >>= \x -> [2*x] >> return x
[1,2,3,4,5,6,7,8,9,10]

// >>の特性によりguardで得られた空のリストを変換できる
*Main> [1..10] >>= \x -> guard (x `mod` 2 == 0)
[(),(),(),(),()]
*Main> [1..10] >>= \x -> guard (x `mod` 2 == 0) >> return x
[2,4,6,8,10]
```

この例の構文糖衣は``*Main> [x | x <- [1..10], x `mod` 2 == 0]``となる。

#### 騎士の旅
このguard及びリストモナドによる演算の良い例が紹介されている。  
ここでは紹介しないが是非読んで手を動かしてみるといい練習になり理解も深まると思うで是非やってみてください。

### モナド則
ファンクターやアプリカティブファンクターと同じようにモナドにも満たすべき法則がある。そんなモナド則をここでは紹介する。紹介する法則を満たしていたらなぜ正しいモナドであるかまでについては触れない(わからない)。

#### 左恒等性
第一のモナド則としてreturnを使って値をデフォルトの文脈に入れたものを>>=を使って関数に食わせた結果は単にその値を関数に適用した結果と等価である。  
つまりは`return x >>= f == f x`を意味する。何種類かのモナドで試してみる。

```
*Main> return 10 >>= \x -> Just (x+1)
Just 11
*Main> (\x -> Just (x+1)) 10
Just 11

*Main> return 10 >>= \x -> [x,x+1,x+2]
[10,11,12]
*Main> (\x -> [x,x+1,x+2]) 10
[10,11,12

*Main> return "Hoge" >>= putStrLn
Hoge
*Main> putStrLn "Hoge"
Hoge
```

#### 右恒等性
第二のモナド則は>>=を使ってモナド値をreturnに食わせた結果は元のモナド値と不変である。式で表現すると`m >>= return == m`となる。  
これも色々試してみる。

```
*Main> Just 10 >>= return
Just 10
*Main> [1,2,3] >>= return
[1,2,3]
```

#### 結合法則
最後の法則は紹介だけする。以下の式がそれにあたる。これはモナドの結合法則となる。

```
(m >>= f) >>= g == m >> (\x -> f x >>= g)
```
