# すごいHな勉強会
## 第十三章 - モナドがいっぱい
### アプリカティブファンクターを強化する
まずは復習から。  
ファンクターを導入した動機はfをFunctorとした場合
1. (a -> b)型の関数を(f a -> f b)にリフトさせる
2. (a -> b)型の関数でf aをf bに写す  

の二つであった。  

では仮にfに(a -> b)型の関数が包まれていた場合どのようにすれば良いのだろうか？  
例えばJust (\*2)があったとして、それをJust 5に適用するには？他にもJust 5がNothingに変わったら？Maybe a型ではなくリストの[(\*2), (+4)]があったとして、それを[1, 2, 3]に適用するには？  
これらを解決するために、Funtor型クラスをさらに改良したApplicative型クラスが導入された。

```
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b
```

(<\*>)を使うことによってJust (\*2)をJust 5に適用することができるようになった。  
またpureではどのような型でも文脈に応じてアプリカティブインスタンス型に入れる操作が可能となった。1を[1]にしたりJust 1にしたりする操作のことである。  

ここでモナドはある要望を叶えるためにアプリカティブ値が自然に拡張された。  
その要望とは「普通の値aを取って文脈付きの値を返す関数に、文脈付きの値m aを渡したい」というものである。言い換えると、a -> m b型の関数をm a型の値に適用したいと言うことである。つまりは以下の関数が欲しいということになる。

```
(>>=) :: (Monad m) => m a -> (a -> m b) -> m a
```

(>>=)は**バインド**と読む。mはMonadの頭文字。
モナドは(>>=)をサポートするアプリカティブファンクターにすぎない。  
普通の値aを普通の関数(a -> b)に食わせるのは簡単。では文脈付きの値m aを普通の値をとってm aを返す関数に食わせるにはどうすれば良いのであろうか？  
この章ではそのやり方について見ていくことにする。

### Maybeから始めるモナド
ここからはファンクターとアプリカティブファンクターを少し振り返ってからモナドの具体例を見ていく。まずはMaybe。  
Maybe a型の値はa型の値を示しているが、Maybeに包まれることで同時に失敗する可能性という文脈が付いている。例えばJust "hoge"は文字列"hoge"がそこに実在することを意味するが、Nothingという値は"無"又は計算が失敗したということを意味する。  
ファンクターとして見たMaybeに対して関数をfmapするとJust値であれば中身に関数を適用するがNothingであればNothingを返す。  
```
Prelude> fmap (+1) $Just 1
Just 2
Prelude> fmap (+1) Nothing
Nothing
```

アプリカティブファンクターとしてののMaybeの機能も似たようなものになる。  
ただしアプリカティブファンクターになると値だけではなく値に適用する関数にも文脈がつく。つまりJust (\*2)のようにMaybe a型であれば関数がJustに包まれる。
関数又は値がNothingなら結果もNothingになるので失敗が伝搬する。

```
*Main> Just (*2) <*> Just 2
Just 4
*Main> Nothing  <*> Just 2
Nothing

// アプリカティブスタイル
*Main> (*) <$> Just 2 <*> Just 4
Just 8
*Main> (*) <$> Nothing  <*> Just 4
Nothing
```

それではいよいよMaybeにとっての>>=をどう定義すればよいか考えてみる。  
\>>=は「モナド値」と「普通の値を取ってモナド値を返す関数」を引数にとり、モナド値を返す関数である。  
「普通の値を取ってモナド値を返す関数」とは具体的には例えば\x -> Just (x+1)などがある。これは普通の値xをとって1を足してからJustに包んで返す関数である。ではこれをどうしたらMaybe a型に適用することができるのであろうか？  

この答えは割と簡単でパターンマッチを使えばできる。  
NothingならNothingを返し、Just値ならJustの中身を取り出してそれを関数に適用すれば良い。  
一旦>>=のと呼ぶのはやめてapplyMaybeという名前で関数を作ることを考える。  
Maybe a型に具体化された場合「Maybe a型の値」と「普通の値を取ってMaybe b型の値をとる関数」を引数にとってMaybe a型の値を返すように定義してやれば良い。  

```
applyMaybe :: Maybe a -> (a -> Maybe b) - Maybe b
applyMaybe Nothing f = Nothing
applyMaybe (Just x) f = f x
```

これは>>=をMaybeに具体化した関数である。早速使ってみる。

```
*Main> Just 10 `applyMaybe` \x -> Just (x+1)
Just 11
*Main> Nothing `applyMaybe` \x -> Just (x+1)
Nothing
```

このapplyMaybeによって「モナド値」に「普通の値を取ってモナド値を返す関数」を適用する方法が見えてきた。  
ではそれの何が便利なのであろうか？それをこれから見ていくことにする。

### Monad型クラス
Monadの型クラスを紹介する。以下は定義。

```
class Applicative m =>  Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  fail :: String -> m a
```

モナドはアプリカティブファンクターの強化版なのでApplicative型クラス制約がつく。  
最小完全定義は>>=なのでそれさえ定義してしまえばMonad型クラスのインスタンスになる。  
returnは通常の値を受けとってモナド型クラスのインスタンスに包んで返す。  
\>>=は「モナド値」及び「通常の値を取ってモナド値を返す関数」を取りモナド値を返す。  
\>>及びfailnについては一旦は気にしない。以下にMaybeのMonadインスタンス定義を示す。

```
instance Monad Maybe where
  return x = Just x
  Nothing >>= f = Nothing
  Just x >>= f = f x
  fail _ = Nothing
```

returnはpureと全く同じ動作を、>>=は先ほど定義したapplyMaybeと同じ動作をする。

```
*Main> return 10 :: Maybe Int
Just 10
*Main> return 10 >>= \x -> Just (x+1)
Just 11
*Main> return 10 >>= \x -> Just (x+1) >>= \x -> Just (x^2)
Just 121

// 失敗は伝搬する
*Main> Nothing >>= \x -> return (x+10)
Nothing
*Main> Nothing >>= \x -> Just (x+1) >>= \x -> Just (x^2)
Nothing
```

### 綱渡り
失敗するかもしれない計算が文脈を損なうことなくMaybe a型の値にa -> Maybe b型の関数を適用する方法がわかったので>>=を繰り返し使ってMaybe a型を返す複数の計算を扱う例を見ていく。  

ピエールが綱渡りをする際、持っているバランス棒に鳥がとまってしまう問題がある。左右バランスよくとまる分には問題ないが偏ってしまうとピエールは転落してしまう。  
棒の左右にとまる鳥の数の差が3以内であれば問題ないがそれより多いとピエールは転落する。  

では鳥たちバランス棒の左右の端に飛んできたり飛び去ったりする様子をシミュレートして一定数の取りたちが来たり去ったりしたあともピエールが綱の上にいるかどうかを判定するプログラムを書いてみる。  

#### ひたすらコーデョイング
まずは鳥の数及び左右の鳥の数を表現する型を型シノニムで定義する。

```
type Birds = Int
type Pole = (Birds, Birds)
```

次に左及び右に鳥がとまった後に棒の状態を返す関数をそれぞれ定義する。  
ただし左右の鳥の数の差が3より大きくなったら失敗(ピエールが落ちる)する。

```
landLeft :: Birds -> Pole -> Maybe Pole
landLeft n (left, right)
  | abs ((left + n) - right) < 4 = Just (left + n, right)
  | otherwise                    = Nothing

landRight:: Birds -> Pole -> Maybe Pole
landRight n (left, right)
  | abs (left - abs (right + n)) < 4 = Just (left, right + n)
  | otherwise                        = Nothing
```

これにより左右の鳥の数の差が4以上になったら失敗する

```
// 成功
*Main> landLeft 3 (0, 0)
Just (3,0)
*Main> landRight 3 (0, 0)
Just (0,3)

// 失敗
*Main> landLeft 4 (0, 0)
Nothing
*Main> landRight 4 (0, 0)
Nothing
```

これは初期状態(0, 0)から次の瞬間鳥がどちらかにとまった後を表しているにすぎない。  
では仮に次の順番で鳥が行ったり来たりした後に果たしてピエールはロープの上に留まり続けているのであろうか？

1. ピエールが網の上に立つ(鳥はまだ来てない)
2. 左に鳥が2羽来る
3. 右に鳥が3羽来る
4. 左から鳥が1羽飛ぶ
5. 右に鳥が1羽来る

これを計算するために>>=を使うことができる。  
失敗(Nothing)は伝搬するため、計算の結果出力された値がNothingであれば失敗(ピエールが転落)しており、Just値が帰ってきたらピエールは綱の上に留まって入られたことになる。早速やってみる。

```
*Main> return (0, 0) >>= landLeft 2 >>= landRight 3 >>= landLeft (-1) >>= landRight 1
Just (1,4)
```

最後にJust値が返ってきたのでピエールは網の上に留まり続けることができたということになる。  
ではこれは何が起きたのか順を追って説明する。

1. ピエールが網の上に立った初期状態(0, 0)を>>=の文脈に入れるためにreturnでJustに包む(型指定をしなくても計算の文脈でよろしくMaybe a型だとよろしく解釈してくれる)
2. Just (0, 0) >> landLeft 2が評価される。landLeft 2は引数を一つとることでカリー化されPole -> Maybe Poleを返す一引数関数となり、>>=の性質によりJust (0, 0)を処理される
3. このタイミングでJust (2, 0)となっておりまだ差は4より小さい。そしてこの値をそのまま2と同じようにlandRight 3に食わせる
4. Just (2, 3)となっている。同じくlandLeft (-1)に食わせる
5. Just (1, 3)であり、landRight 1に食わせる

上記1~5の手順を踏むことで最終的に得られる結果はJust (1, 4)となる。  
最終的な結果もそうであるが、途中結果でも一回も左右の鳥の数の差が4以上になることはなかった。そのためこの計算は成功でピエールが綱の上から落ちることはなかった。  

では3番目の手順で鳥が6羽来た場合はどうなるのであろうか？

```
*Main> return (0, 0) >>= landLeft 2 >>= landRight 6 >>= landLeft (-1) >>= landRight 1
Nothing
```

予想は大方つくがNothingが返っている。  
これは計算が途中で失敗してピエールが落ちたことを意味している。  

このように>>=を使うことである意味で状態を保持しながらその値を連続して使っていくことができることがわかった。

#### ロープの上のバナナ
今度は左右の鳥の数の差に関わらずピエールが失敗する関数を作ってみる。  
棒の上にバナナがあれば誰だって落ちる。

```
banana :: Pole -> Maybe Pole
banana _ = Nothing
```

これをピエールが網の上に留まっていられる例の真ん中にはさんでみる。

```
*Main> return (0, 0) >>= landLeft 2 >>= banana >>= landRight 3 >>= landLeft (-1) >>= landRight 1
Nothing
```

予想通りNothingの結果が得られた。  
ちなみに入力に関係なく既定のモナド値を返す関数であれば自作しなくても>>を使えば良い。以下に>>のデフォルト実装を示す。

```
(>>) :: m a -> m b
m >> n = \_ -> n
```

普通の関数であれば引数を無視して既定の値を返す関数の結果はその既定値そのものになるが、モナド値を扱う場合はモナドとしての文脈を考慮する必要がある(通常は規定値を扱うが失敗ならNothingを返すという意味)。早速使ってみる。

```
*Main> Nothing >> Just 10
Nothing
*Main> Just 3 >> Just 4
Just 4
*Main> Just 3 >> Nothing
Nothing
```

先ほどのbananaを挿入した部分と同じところで>>に入れ替えてみる。

```
*Main> return (0, 0) >>= landLeft 2 >> Nothing >>= landRight 3 >>= landLeft (-1) >>= landRight 1
Nothing
```

期待通りの結果が得られた。  
ところでもしMaybeを失敗の文脈がついた値をして>>=に食わせて計算していくという方法を取らなければかなり面倒くさいコードになっていることが想像できる。詳細は割愛する。  

この節では関数適用を>>=にしてモナド値(ここではMaybe a型の値)に適用していくだけで簡単に失敗を処理するやり方を組み込むことができた。  
これは>>=が関数を値に適用するにあたり、値が持っている文脈を保存することができるからである。  
Maybe値に関数を適用すると常にしっぱの可能性が考慮されたコードが出来上がる。  

ちなみに失敗の可能性を考慮し、失敗した場合に何が原因で失敗したかを詳しく知りたい場合はEither a b型を使えば解決できる。これは宿題。

### do記法
モナドは便利なのでモナド専用構文まで用意されている。それはdo記法。  
IOの章で複数のI/Oアクションを糊付けするさいに使ったが、実はdo記法はIOモナドだけではなくあらゆるモナドに使うことができる。使いかたはI/Oを糊付けする際のやり方と同じで複数のモナド値を糊付けするものである。  

do記法を扱う前に次の例を見てみる。

```
*Main> Just 3 >>= \x -> Just (show x ++ "!")
Just "3!"
```

これは簡単。では次の例はどうだろうか？

```
*Main> Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))
Just "3!"
```

入れ子構造になっている。  
これはxに最初のJust 3の3が入り、yにはJust "!"の"!"が入っていることがわかる。  
これをよく見るとxに3を束縛し、yに"!"を束縛しているように見える。実際do記法を使うことで以下のように表現することができる。

```
foo :: Maybe String
foo = do
  x <- Just 3
  y <- Just "!"
  Just (show x ++ y)
```

I/Oアクションにおけるdo記法の場合<-は例えばIO String型のI/Oアクションの実行結果として得られるStringの値を変数に束縛していた。  
この場合はMaybe StringのString値を変数に束縛している。最後はfooが返す型(Maybe String)で終了している。  

このようにdo記法を使うことで>>=で連鎖的に記述される処理を手続き的に記述することができる。失敗は伝搬するため、以下のように記述すればもちろん結果はNothingになる。

```
foo :: Maybe String
foo = do
  x <- Just 3
  y <- Just "!"
  Nothing
  Just (show x ++ y)
```

#### do自由自在
do式はlet行を除きすべてモナド値で構成される。モナドの結果を調べるには<-を使う。例えば、変数を<-でMaybe Stringの結果に束縛するならその変数はStringとなる。これは>>=を使ってモナド値をラムダ式に食わせた時と全く同じである。  

do式の最後のモナド値だけは<-で結果を束縛することはできない。その理由は最後のモナドで<-を使ってもそれを受けるラムダ式が存在しないためである。

```
*Main> Just 10 >>= \x -> Just (x+1)
Just 11
```

上の例で考えてみるとJust 10に食わせる関数が\x -> Just (x+1)とあるのでx <- 10とすることができるが、その結果のJust 11に対して食わせる関数はもうない。  
do記法もこれと同じで最後に束縛して終わらせようと思ってもその結果を食わせる関数が存在しないためエラーとなる。

#### 帰ってきたピエール
ピエールの綱渡りの動作ももちろんdo記法を使って表現することができる。
